/*
 * The MIT License (MIT)
 *
 * Copyright (c) 2020 Yonatan Goldschmidt
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <gcc-plugin.h>
#include <tree.h>
#include <print-tree.h>
#include <tree-iterator.h>
#include <c-family/c-common.h>


int plugin_is_GPL_compatible; // must be defined for the plugin to run

static tree printf_decl = NULL_TREE;

// heuristic to check if cond_expr is the expression generated by glibc's "assert" macro, which is:
// ((void) sizeof ((EXPR) ? 1 : 0), __extension__ ({ if (EXPR) ; else __assert_fail ("EXPR", "file.c", line, __extension__ __PRETTY_FUNCTION__); }))
// the generated cond_expr has COND_EXPR_COND as the assert's condition,
// COND_EXPR_THEN is a nop_expr and COND_EXPR_ELSE is a call_expr calling to "__assert_fail".
static bool is_assert_fail_cond_expr(tree cond_expr) {
    gcc_assert(TREE_CODE(cond_expr) == COND_EXPR);

    tree expr_else = COND_EXPR_ELSE(cond_expr);
    return (
        TREE_CODE(COND_EXPR_THEN(cond_expr)) == NOP_EXPR &&
        TREE_CODE(expr_else) == CALL_EXPR &&
        TREE_CODE(CALL_EXPR_FN(expr_else)) == ADDR_EXPR &&
        TREE_CODE(TREE_OPERAND(CALL_EXPR_FN(expr_else), 0)) == FUNCTION_DECL &&
        0 == strcmp("__assert_fail", IDENTIFIER_POINTER(DECL_NAME(TREE_OPERAND(CALL_EXPR_FN(expr_else), 0))))
    );
}

// lol
#define build_string_literal_from_literal(s) build_string_literal(sizeof(s), s)

// cond_expr is an expression that matched is_assert_fail_cond_expr().
// this function returns a new expression that'll be used to replace it.
static tree patch_assert(tree cond_expr) {
    gcc_assert(TREE_CODE(cond_expr) == COND_EXPR);

    // for current code in test.c, the condition is an eq_expr whose 1st operand
    // is the variable.
    gcc_assert(TREE_CODE(COND_EXPR_COND(cond_expr)) == EQ_EXPR);
    tree variable = TREE_OPERAND(COND_EXPR_COND(cond_expr), 0);
    gcc_assert(TREE_CODE(variable) == PARM_DECL); // make sure it's indeed a variable reference
    const char *variable_name = IDENTIFIER_POINTER(DECL_NAME(variable));
    // build the printf with the variable name and its value.
    tree params =
        tree_cons(NULL_TREE, build_string_literal_from_literal("name: '%s', value: %d\n"),
        tree_cons(NULL_TREE, build_string_literal(strlen(variable_name) + 1, variable_name),
        tree_cons(NULL_TREE, variable,
            NULL_TREE)));
    gcc_assert(printf_decl != NULL_TREE);
    tree call = build_function_call(EXPR_LOCATION(COND_EXPR_ELSE(cond_expr)), printf_decl, params);

    // insert our printf call before the original else expression.
    tree t = alloc_stmt_list();
    append_to_statement_list(call, &t);
    append_to_statement_list(COND_EXPR_ELSE(cond_expr), &t);

    // in the future I can use this, which also works:
    // return build3_loc(EXPR_LOCATION(COND_EXPR_ELSE(cond_expr)), COND_EXPR, void_type_node, COND_EXPR_COND(cond_expr), COND_EXPR_THEN(cond_expr), t);
    // meanwhile, just replacing is fine
    COND_EXPR_ELSE(cond_expr) = t;
    return cond_expr;
}

static void iterate_bind_expr(tree bind) {
    gcc_assert(TREE_CODE(bind) == BIND_EXPR);

    tree body = BIND_EXPR_BODY(bind);
    if (TREE_CODE(body) == STATEMENT_LIST) {
        for (tree_stmt_iterator i = tsi_start(body); !tsi_end_p(i); tsi_next(&i)) {
            tree stmt = tsi_stmt(i);

            if (TREE_CODE(stmt) == BIND_EXPR) {
                iterate_bind_expr(stmt);
            }
        }
    } else {
        gcc_assert(TREE_CODE(body) == COND_EXPR); // I don't know of other possible types yet

        if (is_assert_fail_cond_expr(body)) {
            BIND_EXPR_BODY(bind) = patch_assert(body);
        }
    }
}

static void pre_genericize_callback(void *event_data, void *user_data) {
    (void)user_data;

    tree t = (tree)event_data;

    if (TREE_CODE(t) != FUNCTION_DECL || 0 != strcmp("test_func", IDENTIFIER_POINTER(DECL_NAME(t)))) {
        return;
    }

    tree bind = DECL_SAVED_TREE(t);
    if (!bind || TREE_CODE(bind) != BIND_EXPR) {
        printf("function body is not BIND_EXPR??\n");
        return;
    }

    iterate_bind_expr(bind);
}

static void finish_decl_callback(void *event_data, void *user_data) {
    tree decl = (tree)event_data;

    // TODO use GCC's lookup_name instead
    if (TREE_CODE(decl) == FUNCTION_DECL && 0 == strcmp("printf", IDENTIFIER_POINTER(DECL_NAME(decl)))) {
        printf_decl = decl;
    }
}

int plugin_init(struct plugin_name_args *plugin_info, struct plugin_gcc_version *version) {
    register_callback(plugin_info->base_name, PLUGIN_PRE_GENERICIZE, pre_genericize_callback, NULL);
    register_callback(plugin_info->base_name, PLUGIN_FINISH_DECL, finish_decl_callback, NULL);

    return 0;
}
